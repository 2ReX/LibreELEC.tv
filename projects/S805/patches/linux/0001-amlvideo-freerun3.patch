From 9b4e1877c34ff8654a3ac9a529810e1662e60fad Mon Sep 17 00:00:00 2001
From: Markus Pfau <pfau@peak3d.de>
Date: Tue, 27 Dec 2016 16:34:21 +0100
Subject: [PATCH] amlvideo freerun3

---
 drivers/amlogic/amports/video.c      | 10 +++++--
 drivers/amlogic/video_dev/amlvideo.c | 53 ++++++++++++++++++++++++++++++------
 2 files changed, 52 insertions(+), 11 deletions(-)

diff --git a/drivers/amlogic/amports/video.c b/drivers/amlogic/amports/video.c
index 66e5c14..bb7ff93 100644
--- a/drivers/amlogic/amports/video.c
+++ b/drivers/amlogic/amports/video.c
@@ -2841,13 +2841,15 @@ static irqreturn_t vsync_isr(int irq, void *dev_id)
     int enc_line;
     unsigned char frame_par_di_set = 0;
     s32 i, vout_type;
+    u32 system_time;
     vframe_t *vf;
     unsigned long flags;
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
     vdin_v4l2_ops_t *vdin_ops = NULL;
     vdin_arg_t arg;
 #endif
-	bool show_nosync=false;
+    bool show_nosync=false;
+    int diff;
 
 #ifdef CONFIG_AM_VIDEO_LOG
     int toggle_cnt;
@@ -2977,8 +2979,10 @@ static irqreturn_t vsync_isr(int irq, void *dev_id)
         timestamp_apts_inc(vsync_pts_inc / vsync_slow_factor);
     }
     if (omx_secret_mode == true) {
-        u32 system_time = timestamp_pcrscr_get();
-        int diff = omx_pts - system_time;
+        atomic_set(&trickmode_framedone, 1);
+        video_notify_flag |= VIDEO_NOTIFY_TRICK_WAIT;
+        system_time = timestamp_pcrscr_get();
+        diff = omx_pts - system_time;
         if (diff>11000 || diff<-11000) {
             timestamp_pcrscr_enable(1);
             //printk("system_time=%d,omx_pts=%d,diff=%d\n",system_time,omx_pts,diff);
diff --git a/drivers/amlogic/video_dev/amlvideo.c b/drivers/amlogic/video_dev/amlvideo.c
index b3fbbac..4387abd 100755
--- a/drivers/amlogic/video_dev/amlvideo.c
+++ b/drivers/amlogic/video_dev/amlvideo.c
@@ -63,11 +63,12 @@
 
 #define AMLVIDEO_POOL_SIZE 16
 static vfq_t q_ready;
+static vfq_t q_omx;
 extern bool omx_secret_mode;
+static u32 omx_frame_index = 0;
 static u8 first_frame;
 static u32 vpts_last;
 
-
 #define DUR2PTS(x) ((x) - ((x) >> 4))
 #define DUR2PTS_RM(x) ((x) & 0xf)
 
@@ -157,6 +158,7 @@ static struct vivi_fmt formats[] = {
     };
 
 struct vframe_s *amlvideo_pool_ready[AMLVIDEO_POOL_SIZE+1];
+struct vframe_s *amlvideo_pool_omx[AMLVIDEO_POOL_SIZE+1];
 /* ------------------------------------------------------------------
  *           provider operations
  *-----------------------------------------------------------------*/
@@ -193,8 +195,8 @@ static int amlvideo_vf_states(vframe_states_t *states, void *op_arg) {
     //spin_lock_irqsave(&lock, flags);
     states->vf_pool_size    = AMLVIDEO_POOL_SIZE;
     states->buf_recycle_num = 0;
-    states->buf_free_num    =  AMLVIDEO_POOL_SIZE - vfq_level(&q_ready);
-    states->buf_avail_num   = vfq_level(&q_ready);
+    states->buf_free_num    = AMLVIDEO_POOL_SIZE - (vfq_level(&q_ready) + vfq_level(&q_omx));
+    states->buf_avail_num   = vfq_level(&q_ready) | (vfq_level(&q_omx) << 16);
     //spin_unlock_irqrestore(&lock, flags);
     return 0;
 }
@@ -319,6 +321,7 @@ static int video_receiver_event_fun(int type, void* data, void* private_data) {
             vf_reg_provider(&amlvideo_vf_prov);
             vf_notify_receiver(PROVIDER_NAME,VFRAME_EVENT_PROVIDER_START,NULL);
             vfq_init(&q_ready, AMLVIDEO_POOL_SIZE+1, &amlvideo_pool_ready[0]);
+            vfq_init(&q_omx, AMLVIDEO_POOL_SIZE+1, &amlvideo_pool_omx[0]);
         }
     }
     else if (type == VFRAME_EVENT_PROVIDER_FR_HINT) {
@@ -527,6 +530,31 @@ static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p) {
     int ret = 0;
     if (omx_secret_mode == true) {
         trace_qbuf(p->index);
+        if (freerun_mode == 3) {
+
+            vframe_t *vf;
+
+            //skip dropped frames
+            while ((vf = vfq_peek(&q_omx)))
+            {
+                u32 index = (int)(vf->pts_us64);
+                if (index < p->index)
+                {
+                    printk("amlvideo vidioc_qbuf: skip index %u->%u\n",index, p->index);
+                    vf_put(vfq_pop(&q_omx), RECEIVER_NAME);
+                    continue;
+                }
+                else if (index == p->index)
+                {
+                    vfq_pop(&q_omx);
+                    if (!(p->flags & V4L2_BUF_FLAG_DONE))
+                        vfq_push(&q_ready, vf);
+                    else
+                        vf_put(vf, RECEIVER_NAME);
+                }
+                break;
+            }
+        }
         return ret;
     }
     if (ppmgrvf) {
@@ -583,7 +611,7 @@ static int freerun_dqbuf(struct v4l2_buffer *p) {
     int omx_ready = 0;
     if (omx_secret_mode == true) {
         omx_ready = vfq_level(&q_ready);
-        if (omx_ready > AMLVIDEO_POOL_SIZE-1) {
+        if (omx_ready + vfq_level(&q_omx)> AMLVIDEO_POOL_SIZE-1) {
             my_wb_debug++;
             return -EAGAIN;
         }
@@ -601,9 +629,7 @@ static int freerun_dqbuf(struct v4l2_buffer *p) {
         return -EAGAIN;
     }
     if (omx_secret_mode == true) {
-        vfq_push(&q_ready, ppmgrvf);
         p->index = 0;
-        p->timestamp.tv_sec = 0;
 
         if (ppmgrvf->pts) {
             first_frame = 1;
@@ -618,6 +644,16 @@ static int freerun_dqbuf(struct v4l2_buffer *p) {
         trace_dqbuf(p->index, my_wf_debug, my_wb_debug, omx_ready);
         my_wf_debug = 0;
         my_wb_debug = 0;
+
+        if (freerun_mode != 3)
+            vfq_push(&q_ready, ppmgrvf);
+        else
+        {
+            ppmgrvf->pts_us64 = omx_frame_index;
+            p->index = omx_frame_index++;
+            vfq_push(&q_omx, ppmgrvf);
+        }
+
         return ret;
     }
     if (ppmgrvf->pts != 0) {
@@ -627,7 +663,7 @@ static int freerun_dqbuf(struct v4l2_buffer *p) {
 		ppmgrvf->pts=timestamp_vpts_get();
     }
 
-	if(!ppmgrvf->pts)
+    if(!ppmgrvf->pts)
         ppmgrvf->pts_us64=ppmgrvf->pts*100/9;
 
     if (unregFlag || startFlag) {
@@ -721,7 +757,7 @@ static int normal_dqbuf(struct v4l2_buffer *p) {
 static int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p) {
     int ret = 0;
 
-    if (freerun_mode == 1) {
+    if (freerun_mode == 1 || freerun_mode == 3) {
         ret = freerun_dqbuf(p);
     }else if (freerun_mode == 2) {
         ret = freerun_cleancache_dqbuf(p);
@@ -828,6 +864,7 @@ static int amlvideo_open(struct file *file) {
     unregFlag = 0;
     startFlag = 1;
     freerun_start = 0;
+    omx_frame_index = 0;
     mutex_unlock(&vfpMutex);
     mutex_lock(&dev->mutex);
     dev->users++;
-- 
1.8.3.1

